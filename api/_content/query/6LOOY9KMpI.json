[{"_path":"/til/algoritmos","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Algoritmos","description":"Algoritmos que todo programador deveria conhecer bem.","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Algoritmos que todo programador deveria conhecer bem."}]},{"type":"element","tag":"h2","props":{"id":"estruturas-lineares-de-dados"},"children":[{"type":"text","value":"Estruturas lineares de dados"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"[Arrays]("},{"type":"element","tag":"binding","props":{"value":"< ref \"cpp-array.md\" >"},"children":[]},{"type":"text","value":")"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Linked List - Single and Doubly"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Stack"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Queues"}]}]},{"type":"element","tag":"h2","props":{"id":"algoritmos-básicos"},"children":[{"type":"text","value":"Algoritmos básicos"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Sorting - Merge Sort, Insertion Sort, Quick Sort, Number of inversions"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Matrix Multiplication (just know the algo if not implement it)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Prime Sieving"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Modular Math including multiplication and division"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Euclidean Algorithm for GCD, Modular Inverse, Fast Exponentiation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Fibonacci number with matrix multiplication"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Probability distribution and expected value"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Stats - Mean, Median, Variance, Bayes theorem"}]}]},{"type":"element","tag":"h2","props":{"id":"técnicas-populares"},"children":[{"type":"text","value":"Técnicas populares"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Divide and Conquer - Binary Search, Maximum Subarray"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Greedy Algorithms - Activity Selection, Huffman encoding"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Dynamic Programming - Matrix Chain Multiplication, Knapsack,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Linear Programming - Variable Maximisation, Linear time sorting"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"String Algorithms - Manacher, LCS, Edit Distance"}]}]},{"type":"element","tag":"h2","props":{"id":"estruturas-não-lineares-de-dados"},"children":[{"type":"text","value":"Estruturas não lineares de dados"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Trees - Binary Tree, General Tree, Lowest Common Ancestor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Binary Search Tree - Inorder Traversal, Level order traversal, finding kth largest element, diameter, depth, number of nodes, etc."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Heaps - Array Implementation, Heapify, Heap Sort"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Union Find"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hash Table - Linear Probing, Open addressing, Collision avoidance"}]}]},{"type":"element","tag":"h2","props":{"id":"grafos"},"children":[{"type":"text","value":"Grafos"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Adjacency List, Adjacency Matrix, Weighted Edge Graphs"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Basic Traversal algos - Breadth First Search, Depth First Search, etc"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Shortest Path Finding Algorithm - Dijkstra, Floyd Warshal, Bellman Ford"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Minimum Spanning Tree - Kruskal's Algo, Prim's Algo"}]}]},{"type":"element","tag":"h2","props":{"id":"árvores-avançadas-e-grafos"},"children":[{"type":"text","value":"Árvores avançadas e grafos"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Balanced Trees - AVL, Red-Black"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Heavy Light Decomposition, B+ Trees, Quad Tree"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Advance Graph - Min Cut, Max Flow"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Maximum Matching - Hall's Marriage"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hamiltonian Cycle"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Edge Graphs / Line Graphs"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Strongly Connected Components"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Dominant Sub-Graph, Vertex Cover, Travelling Salesman - Approx algos"}]}]},{"type":"element","tag":"h2","props":{"id":"algoritmos-avançados-para-string"},"children":[{"type":"text","value":"Algoritmos avançados para String"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Knuth Morris Pratt Algorithm"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Rabin Karp Algorithm"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Tries and Compressed Tries"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Prefix Trees, Suffix Trees, Suffix Automation - Ukkonen Algorithm"}]}]},{"type":"element","tag":"h2","props":{"id":"matemática-avançada"},"children":[{"type":"text","value":"Matemática avançada"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Fast Fourier Transformation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Primality Testing"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Computational Geometry - Closest point pair, Voronoi diagram, Convex Hull"}]}]},{"type":"element","tag":"h2","props":{"id":"tópicos-gerais-avançados"},"children":[{"type":"text","value":"Tópicos gerais avançados"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Iterating through all combination / permutation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Bit manipulation"}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.quora.com/What-algorithms-should-I-know-to-become-a-good-programmer/answer/Ashish-Kedia?ch=3&share=ae955848&srid=zRrj","rel":["nofollow"]},"children":[{"type":"text","value":"What algorithms should I know to become a good programmer?"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/AnthonyCalandra/modern-cpp-features/blob/master/README.md","rel":["nofollow"]},"children":[{"type":"text","value":"C++20/17/14/11"}]}]}]}]},"date":"2020-01-03T00:00:00.000Z","draft":false,"tags":["Algoritmos"],"Thumbnail":"img/headers/algorithm.jpg","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Algoritmos que todo programador deveria conhecer bem."}]},{"type":"element","tag":"h2","props":{"id":"estruturas-lineares-de-dados"},"children":[{"type":"text","value":"Estruturas lineares de dados"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"[Arrays]("},{"type":"element","tag":"binding","props":{"value":"< ref \"cpp-array.md\" >"},"children":[]},{"type":"text","value":")"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Linked List - Single and Doubly"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Stack"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Queues"}]}]},{"type":"element","tag":"h2","props":{"id":"algoritmos-básicos"},"children":[{"type":"text","value":"Algoritmos básicos"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Sorting - Merge Sort, Insertion Sort, Quick Sort, Number of inversions"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Matrix Multiplication (just know the algo if not implement it)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Prime Sieving"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Modular Math including multiplication and division"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Euclidean Algorithm for GCD, Modular Inverse, Fast Exponentiation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Fibonacci number with matrix multiplication"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Probability distribution and expected value"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Stats - Mean, Median, Variance, Bayes theorem"}]}]},{"type":"element","tag":"h2","props":{"id":"técnicas-populares"},"children":[{"type":"text","value":"Técnicas populares"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Divide and Conquer - Binary Search, Maximum Subarray"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Greedy Algorithms - Activity Selection, Huffman encoding"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Dynamic Programming - Matrix Chain Multiplication, Knapsack,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Linear Programming - Variable Maximisation, Linear time sorting"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"String Algorithms - Manacher, LCS, Edit Distance"}]}]},{"type":"element","tag":"h2","props":{"id":"estruturas-não-lineares-de-dados"},"children":[{"type":"text","value":"Estruturas não lineares de dados"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Trees - Binary Tree, General Tree, Lowest Common Ancestor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Binary Search Tree - Inorder Traversal, Level order traversal, finding kth largest element, diameter, depth, number of nodes, etc."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Heaps - Array Implementation, Heapify, Heap Sort"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Union Find"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hash Table - Linear Probing, Open addressing, Collision avoidance"}]}]},{"type":"element","tag":"h2","props":{"id":"grafos"},"children":[{"type":"text","value":"Grafos"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Adjacency List, Adjacency Matrix, Weighted Edge Graphs"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Basic Traversal algos - Breadth First Search, Depth First Search, etc"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Shortest Path Finding Algorithm - Dijkstra, Floyd Warshal, Bellman Ford"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Minimum Spanning Tree - Kruskal's Algo, Prim's Algo"}]}]},{"type":"element","tag":"h2","props":{"id":"árvores-avançadas-e-grafos"},"children":[{"type":"text","value":"Árvores avançadas e grafos"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Balanced Trees - AVL, Red-Black"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Heavy Light Decomposition, B+ Trees, Quad Tree"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Advance Graph - Min Cut, Max Flow"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Maximum Matching - Hall's Marriage"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hamiltonian Cycle"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Edge Graphs / Line Graphs"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Strongly Connected Components"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Dominant Sub-Graph, Vertex Cover, Travelling Salesman - Approx algos"}]}]},{"type":"element","tag":"h2","props":{"id":"algoritmos-avançados-para-string"},"children":[{"type":"text","value":"Algoritmos avançados para String"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Knuth Morris Pratt Algorithm"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Rabin Karp Algorithm"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Tries and Compressed Tries"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Prefix Trees, Suffix Trees, Suffix Automation - Ukkonen Algorithm"}]}]},{"type":"element","tag":"h2","props":{"id":"matemática-avançada"},"children":[{"type":"text","value":"Matemática avançada"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Fast Fourier Transformation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Primality Testing"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Computational Geometry - Closest point pair, Voronoi diagram, Convex Hull"}]}]},{"type":"element","tag":"h2","props":{"id":"tópicos-gerais-avançados"},"children":[{"type":"text","value":"Tópicos gerais avançados"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Iterating through all combination / permutation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Bit manipulation"}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.quora.com/What-algorithms-should-I-know-to-become-a-good-programmer/answer/Ashish-Kedia?ch=3&share=ae955848&srid=zRrj","rel":["nofollow"]},"children":[{"type":"text","value":"What algorithms should I know to become a good programmer?"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/AnthonyCalandra/modern-cpp-features/blob/master/README.md","rel":["nofollow"]},"children":[{"type":"text","value":"C++20/17/14/11"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"estruturas-lineares-de-dados","depth":2,"text":"Estruturas lineares de dados"},{"id":"algoritmos-básicos","depth":2,"text":"Algoritmos básicos"},{"id":"técnicas-populares","depth":2,"text":"Técnicas populares"},{"id":"estruturas-não-lineares-de-dados","depth":2,"text":"Estruturas não lineares de dados"},{"id":"grafos","depth":2,"text":"Grafos"},{"id":"árvores-avançadas-e-grafos","depth":2,"text":"Árvores avançadas e grafos"},{"id":"algoritmos-avançados-para-string","depth":2,"text":"Algoritmos avançados para String"},{"id":"matemática-avançada","depth":2,"text":"Matemática avançada"},{"id":"tópicos-gerais-avançados","depth":2,"text":"Tópicos gerais avançados"},{"id":"referências","depth":2,"text":"Referências"}]}},"_type":"markdown","_id":"content:til:algoritmos.md","_source":"content","_file":"til/algoritmos.md","_extension":"md"}]