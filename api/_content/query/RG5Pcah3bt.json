{"_path":"/til/cpp-thread","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Thread em C++","description":"Escrevendo funções e classes para execução em paralelo.","excerpt":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"thread-com-função-sem-argumentos"},"children":[{"type":"text","value":"Thread com função sem argumentos"}]},{"type":"element","tag":"code","props":{"code":"void foo() {\n  cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n}\n\nvoid run () {\n  thread t1( foo );\n  // Algum processamento...\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void foo() {\n  cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n}\n\nvoid run () {\n  thread t1( foo );\n  // Algum processamento...\n  t1.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-função-passando-parâmetros-por-valor"},"children":[{"type":"text","value":"Thread com função passando parâmetros por valor"}]},{"type":"element","tag":"code","props":{"code":"void fooByRef( int & a ) {\n  while( true ) {\n    cout << \"O valor é \" << a << endl;\n    this_thread::sleep_for( chrono::milliseconds( 1000 ) );\n  }\n}\n\nvoid run () {\n  int p = 9;\n  thread t2( fooByRef, std::ref( p ) ); // usar o wrapper ref para não passar por valor\n  // Algum processamento...\n  this_thread::sleep_for( chrono::milliseconds( 5000 ) );\n  p = 30;\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void fooByRef( int & a ) {\n  while( true ) {\n    cout << \"O valor é \" << a << endl;\n    this_thread::sleep_for( chrono::milliseconds( 1000 ) );\n  }\n}\n\nvoid run () {\n  int p = 9;\n  thread t2( fooByRef, std::ref( p ) ); // usar o wrapper ref para não passar por valor\n  // Algum processamento...\n  this_thread::sleep_for( chrono::milliseconds( 5000 ) );\n  p = 30;\n  t1.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-função-passando-parâmetros-por-referência"},"children":[{"type":"text","value":"Thread com função passando parâmetros por referência"}]},{"type":"element","tag":"code","props":{"code":"void foo( int a, int b ) {\n}\n\nvoid run () {\n  int p = 9;\n  int q = 8;\n  thread t1( foo, p, q );\n  // Algum processamento...\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void foo( int a, int b ) {\n}\n\nvoid run () {\n  int p = 9;\n  int q = 8;\n  thread t1( foo, p, q );\n  // Algum processamento...\n  t1.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-classe-callable"},"children":[{"type":"text","value":"Thread com classe callable"}]},{"type":"element","tag":"code","props":{"code":"class CallableClass {\n  public:\n    void operator()() {\n      cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n    }\n};\n\nvoid run() {\n  CallableClass obj;\n  thread t2( obj );\n  // Algum processamento...\n  t2.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class CallableClass {\n  public:\n    void operator()() {\n      cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n    }\n};\n\nvoid run() {\n  CallableClass obj;\n  thread t2( obj );\n  // Algum processamento...\n  t2.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-lambda"},"children":[{"type":"text","value":"Thread com lambda"}]},{"type":"element","tag":"code","props":{"code":"// Sintaxe\n// [capture-list]( params ) /*mutable*/ /*constexpr*/ /*exception attribute*/ -> ret { body }\n// [capture-list]( params ) -> ret { body }\n// [capture-list]( params ) { body }\n// [capture-list]{ body }\n\nvoid run() {\n  thread t3( []{\n    cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n  } );\n  // Algum processamento...\n  t3.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Sintaxe\n// [capture-list]( params ) /*mutable*/ /*constexpr*/ /*exception attribute*/ -> ret { body }\n// [capture-list]( params ) -> ret { body }\n// [capture-list]( params ) { body }\n// [capture-list]{ body }\n\nvoid run() {\n  thread t3( []{\n    cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n  } );\n  // Algum processamento...\n  t3.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"join-detach-e-terminate"},"children":[{"type":"text","value":"Join, detach e terminate"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Uma thread representa um objeto de execução em nível de hardware e está num estado chamado "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"joinable"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A opções no estado "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"joinable"}]},{"type":"text","value":" são:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" - introduz um ponto de sincronismo e bloqueia a execução"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"detach"}]},{"type":"text","value":" - faz a execução continuar em modo independente"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Após esta escolha a thread se torna "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"non joinable"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Se esquecer de realizar o join ou detach a função "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::terminate"}]},{"type":"text","value":" será chamada pelo destrutor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Um programa com "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::terminate"}]},{"type":"text","value":" é considerado não seguro."}]}]},{"type":"element","tag":"h2","props":{"id":"tratamento-de-exceção"},"children":[{"type":"text","value":"Tratamento de exceção"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Para evitar problemas caso uma exceção for lançada antes do "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" use\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"RAII - Resource acquisition is initialization"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RAII:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Construtor adquire os recursos"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Destrutor libera os recursos"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemplo de código com problema:"}]},{"type":"element","tag":"code","props":{"code":"void run() {\n  thread t4( foo );\n  throw runtime_error( \"Algum erro antes do join/detach\" );\n  t4.join(); // esta linha nunca vai ser executada\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void run() {\n  thread t4( foo );\n  throw runtime_error( \"Algum erro antes do join/detach\" );\n  t4.join(); // esta linha nunca vai ser executada\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A classe "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ThreadGuard"}]},{"type":"text","value":" fornece um auxiliar para garantir que o "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" será\nsempre executado quando o objeto sair do contexto."}]},{"type":"element","tag":"code","props":{"code":"class ThreadGuard {\n  thread & mThread;\n\n  public:\n    // garantir que não haverá conversões implícitas\n    explicit ThreadGuard( thread & t ) : mThread( t ) {  }\n\n    // realiza o join pelo destrutor\n    ~ThreadGuard() { if( mThread.joinable() ) { mThread.join(); } }\n\n    // não permite o uso dos contrutores de cópia e atribuição\n    ThreadGuard( const ThreadGuard & ) = delete;\n    ThreadGuard & operator= ( const ThreadGuard & ) = delete;\n};\n\nvoid run() {\n  thread t4( foo );\n  ThreadGuard tg( t4 ); // quando sair do escopo o join será chamado\n  throw runtime_error( \"Este erro não afeta a thread acima\" );\n}\n","filename":"6,9","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class ThreadGuard {\n  thread & mThread;\n\n  public:\n    // garantir que não haverá conversões implícitas\n    explicit ThreadGuard( thread & t ) : mThread( t ) {  }\n\n    // realiza o join pelo destrutor\n    ~ThreadGuard() { if( mThread.joinable() ) { mThread.join(); } }\n\n    // não permite o uso dos contrutores de cópia e atribuição\n    ThreadGuard( const ThreadGuard & ) = delete;\n    ThreadGuard & operator= ( const ThreadGuard & ) = delete;\n};\n\nvoid run() {\n  thread t4( foo );\n  ThreadGuard tg( t4 ); // quando sair do escopo o join será chamado\n  throw runtime_error( \"Este erro não afeta a thread acima\" );\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"transferindo-a-posse-das-threads"},"children":[{"type":"text","value":"Transferindo a posse das threads"}]},{"type":"element","tag":"code","props":{"code":"void foo() { }\nvoid bar() { }\n\nvoid run() {\n  thread t1( foo );\n  // thread t2 = t1; // Se fizer isso vai gerar erro de compilação\n\n  // usar move para transferir a posse da thread\n  thread t2 = std::move( t1 ); // t1 não é mais dono da thread\n  t1 = thread( bar ); // t1 tem nova thread\n\n  t1.join();\n  t2.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void foo() { }\nvoid bar() { }\n\nvoid run() {\n  thread t1( foo );\n  // thread t2 = t1; // Se fizer isso vai gerar erro de compilação\n\n  // usar move para transferir a posse da thread\n  thread t2 = std::move( t1 ); // t1 não é mais dono da thread\n  t1 = thread( bar ); // t1 tem nova thread\n\n  t1.join();\n  t2.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"threadget_id"},"children":[{"type":"text","value":"thread::get_id()"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna um id único para cada thread ativa em execução"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna 0 para todas as threads não ativas"}]}]},{"type":"element","tag":"code","props":{"code":"void run() {\n  thread t1( foo );\n  thread t2( foo );\n  thread t3;\n\n  cout << t1.get_id() << endl; // 1234\n  cout << t2.get_id() << endl; // 5678\n  cout << t3.get_id() << endl; // 0\n\n  t1.join();\n  t2.join();\n\n  cout << t1.get_id() << endl; // 0\n  cout << t2.get_id() << endl; // 0\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void run() {\n  thread t1( foo );\n  thread t2( foo );\n  thread t3;\n\n  cout << t1.get_id() << endl; // 1234\n  cout << t2.get_id() << endl; // 5678\n  cout << t3.get_id() << endl; // 0\n\n  t1.join();\n  t2.join();\n\n  cout << t1.get_id() << endl; // 0\n  cout << t2.get_id() << endl; // 0\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"sleep_for"},"children":[{"type":"text","value":"sleep_for"}]},{"type":"element","tag":"h2","props":{"id":"stdthis_threadyield"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::this_thread::yield()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna a fatia de tempo"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"reinsere a thread na fila de execução"}]}]},{"type":"element","tag":"h2","props":{"id":"stdthreadhardware_concurrency"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread::hardware_concurrency()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna o número de thread concorrentes suportado pela implementação do sistema"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"considere este valor apenas como uma dica"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"é usualmente o número de cores lógicos"}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.udemy.com/course/modern-cpp-concurrency-in-depth/","rel":["nofollow"]},"children":[{"type":"text","value":"Modern C++ Concurrency in Depth"}]}]}]}]},"date":"2020-06-23T00:00:00.000Z","draft":false,"tags":["C++","cpp","thread"],"Thumbnail":"img/headers/cpp.png","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"thread-com-função-sem-argumentos"},"children":[{"type":"text","value":"Thread com função sem argumentos"}]},{"type":"element","tag":"code","props":{"code":"void foo() {\n  cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n}\n\nvoid run () {\n  thread t1( foo );\n  // Algum processamento...\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void foo() {\n  cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n}\n\nvoid run () {\n  thread t1( foo );\n  // Algum processamento...\n  t1.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-função-passando-parâmetros-por-valor"},"children":[{"type":"text","value":"Thread com função passando parâmetros por valor"}]},{"type":"element","tag":"code","props":{"code":"void fooByRef( int & a ) {\n  while( true ) {\n    cout << \"O valor é \" << a << endl;\n    this_thread::sleep_for( chrono::milliseconds( 1000 ) );\n  }\n}\n\nvoid run () {\n  int p = 9;\n  thread t2( fooByRef, std::ref( p ) ); // usar o wrapper ref para não passar por valor\n  // Algum processamento...\n  this_thread::sleep_for( chrono::milliseconds( 5000 ) );\n  p = 30;\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void fooByRef( int & a ) {\n  while( true ) {\n    cout << \"O valor é \" << a << endl;\n    this_thread::sleep_for( chrono::milliseconds( 1000 ) );\n  }\n}\n\nvoid run () {\n  int p = 9;\n  thread t2( fooByRef, std::ref( p ) ); // usar o wrapper ref para não passar por valor\n  // Algum processamento...\n  this_thread::sleep_for( chrono::milliseconds( 5000 ) );\n  p = 30;\n  t1.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-função-passando-parâmetros-por-referência"},"children":[{"type":"text","value":"Thread com função passando parâmetros por referência"}]},{"type":"element","tag":"code","props":{"code":"void foo( int a, int b ) {\n}\n\nvoid run () {\n  int p = 9;\n  int q = 8;\n  thread t1( foo, p, q );\n  // Algum processamento...\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void foo( int a, int b ) {\n}\n\nvoid run () {\n  int p = 9;\n  int q = 8;\n  thread t1( foo, p, q );\n  // Algum processamento...\n  t1.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-classe-callable"},"children":[{"type":"text","value":"Thread com classe callable"}]},{"type":"element","tag":"code","props":{"code":"class CallableClass {\n  public:\n    void operator()() {\n      cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n    }\n};\n\nvoid run() {\n  CallableClass obj;\n  thread t2( obj );\n  // Algum processamento...\n  t2.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"class CallableClass {\n  public:\n    void operator()() {\n      cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n    }\n};\n\nvoid run() {\n  CallableClass obj;\n  thread t2( obj );\n  // Algum processamento...\n  t2.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-lambda"},"children":[{"type":"text","value":"Thread com lambda"}]},{"type":"element","tag":"code","props":{"code":"// Sintaxe\n// [capture-list]( params ) /*mutable*/ /*constexpr*/ /*exception attribute*/ -> ret { body }\n// [capture-list]( params ) -> ret { body }\n// [capture-list]( params ) { body }\n// [capture-list]{ body }\n\nvoid run() {\n  thread t3( []{\n    cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n  } );\n  // Algum processamento...\n  t3.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"// Sintaxe\n// [capture-list]( params ) /*mutable*/ /*constexpr*/ /*exception attribute*/ -> ret { body }\n// [capture-list]( params ) -> ret { body }\n// [capture-list]( params ) { body }\n// [capture-list]{ body }\n\nvoid run() {\n  thread t3( []{\n    cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n  } );\n  // Algum processamento...\n  t3.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"join-detach-e-terminate"},"children":[{"type":"text","value":"Join, detach e terminate"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Uma thread representa um objeto de execução em nível de hardware e está num estado chamado "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"joinable"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A opções no estado "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"joinable"}]},{"type":"text","value":" são:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" - introduz um ponto de sincronismo e bloqueia a execução"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"detach"}]},{"type":"text","value":" - faz a execução continuar em modo independente"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Após esta escolha a thread se torna "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"non joinable"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Se esquecer de realizar o join ou detach a função "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::terminate"}]},{"type":"text","value":" será chamada pelo destrutor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Um programa com "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::terminate"}]},{"type":"text","value":" é considerado não seguro."}]}]},{"type":"element","tag":"h2","props":{"id":"tratamento-de-exceção"},"children":[{"type":"text","value":"Tratamento de exceção"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Para evitar problemas caso uma exceção for lançada antes do "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" use\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"RAII - Resource acquisition is initialization"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RAII:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Construtor adquire os recursos"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Destrutor libera os recursos"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemplo de código com problema:"}]},{"type":"element","tag":"code","props":{"code":"void run() {\n  thread t4( foo );\n  throw runtime_error( \"Algum erro antes do join/detach\" );\n  t4.join(); // esta linha nunca vai ser executada\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void run() {\n  thread t4( foo );\n  throw runtime_error( \"Algum erro antes do join/detach\" );\n  t4.join(); // esta linha nunca vai ser executada\n}"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A classe "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ThreadGuard"}]},{"type":"text","value":" fornece um auxiliar para garantir que o "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" será\nsempre executado quando o objeto sair do contexto."}]},{"type":"element","tag":"code","props":{"code":"class ThreadGuard {\n  thread & mThread;\n\n  public:\n    // garantir que não haverá conversões implícitas\n    explicit ThreadGuard( thread & t ) : mThread( t ) {  }\n\n    // realiza o join pelo destrutor\n    ~ThreadGuard() { if( mThread.joinable() ) { mThread.join(); } }\n\n    // não permite o uso dos contrutores de cópia e atribuição\n    ThreadGuard( const ThreadGuard & ) = delete;\n    ThreadGuard & operator= ( const ThreadGuard & ) = delete;\n};\n\nvoid run() {\n  thread t4( foo );\n  ThreadGuard tg( t4 ); // quando sair do escopo o join será chamado\n  throw runtime_error( \"Este erro não afeta a thread acima\" );\n}\n","filename":"6,9","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"class ThreadGuard {\n  thread & mThread;\n\n  public:\n    // garantir que não haverá conversões implícitas\n    explicit ThreadGuard( thread & t ) : mThread( t ) {  }\n\n    // realiza o join pelo destrutor\n    ~ThreadGuard() { if( mThread.joinable() ) { mThread.join(); } }\n\n    // não permite o uso dos contrutores de cópia e atribuição\n    ThreadGuard( const ThreadGuard & ) = delete;\n    ThreadGuard & operator= ( const ThreadGuard & ) = delete;\n};\n\nvoid run() {\n  thread t4( foo );\n  ThreadGuard tg( t4 ); // quando sair do escopo o join será chamado\n  throw runtime_error( \"Este erro não afeta a thread acima\" );\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"transferindo-a-posse-das-threads"},"children":[{"type":"text","value":"Transferindo a posse das threads"}]},{"type":"element","tag":"code","props":{"code":"void foo() { }\nvoid bar() { }\n\nvoid run() {\n  thread t1( foo );\n  // thread t2 = t1; // Se fizer isso vai gerar erro de compilação\n\n  // usar move para transferir a posse da thread\n  thread t2 = std::move( t1 ); // t1 não é mais dono da thread\n  t1 = thread( bar ); // t1 tem nova thread\n\n  t1.join();\n  t2.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void foo() { }\nvoid bar() { }\n\nvoid run() {\n  thread t1( foo );\n  // thread t2 = t1; // Se fizer isso vai gerar erro de compilação\n\n  // usar move para transferir a posse da thread\n  thread t2 = std::move( t1 ); // t1 não é mais dono da thread\n  t1 = thread( bar ); // t1 tem nova thread\n\n  t1.join();\n  t2.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"threadget_id"},"children":[{"type":"text","value":"thread::get_id()"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna um id único para cada thread ativa em execução"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna 0 para todas as threads não ativas"}]}]},{"type":"element","tag":"code","props":{"code":"void run() {\n  thread t1( foo );\n  thread t2( foo );\n  thread t3;\n\n  cout << t1.get_id() << endl; // 1234\n  cout << t2.get_id() << endl; // 5678\n  cout << t3.get_id() << endl; // 0\n\n  t1.join();\n  t2.join();\n\n  cout << t1.get_id() << endl; // 0\n  cout << t2.get_id() << endl; // 0\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void run() {\n  thread t1( foo );\n  thread t2( foo );\n  thread t3;\n\n  cout << t1.get_id() << endl; // 1234\n  cout << t2.get_id() << endl; // 5678\n  cout << t3.get_id() << endl; // 0\n\n  t1.join();\n  t2.join();\n\n  cout << t1.get_id() << endl; // 0\n  cout << t2.get_id() << endl; // 0\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"sleep_for"},"children":[{"type":"text","value":"sleep_for"}]},{"type":"element","tag":"h2","props":{"id":"stdthis_threadyield"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::this_thread::yield()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna a fatia de tempo"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"reinsere a thread na fila de execução"}]}]},{"type":"element","tag":"h2","props":{"id":"stdthreadhardware_concurrency"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread::hardware_concurrency()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna o número de thread concorrentes suportado pela implementação do sistema"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"considere este valor apenas como uma dica"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"é usualmente o número de cores lógicos"}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.udemy.com/course/modern-cpp-concurrency-in-depth/","rel":["nofollow"]},"children":[{"type":"text","value":"Modern C++ Concurrency in Depth"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"thread-com-função-sem-argumentos","depth":2,"text":"Thread com função sem argumentos"},{"id":"thread-com-função-passando-parâmetros-por-valor","depth":2,"text":"Thread com função passando parâmetros por valor"},{"id":"thread-com-função-passando-parâmetros-por-referência","depth":2,"text":"Thread com função passando parâmetros por referência"},{"id":"thread-com-classe-callable","depth":2,"text":"Thread com classe callable"},{"id":"thread-com-lambda","depth":2,"text":"Thread com lambda"},{"id":"join-detach-e-terminate","depth":2,"text":"Join, detach e terminate"},{"id":"tratamento-de-exceção","depth":2,"text":"Tratamento de exceção"},{"id":"transferindo-a-posse-das-threads","depth":2,"text":"Transferindo a posse das threads"},{"id":"threadget_id","depth":2,"text":"thread::get_id()"},{"id":"sleep_for","depth":2,"text":"sleep_for"},{"id":"stdthis_threadyield","depth":2,"text":"std::this_thread::yield()"},{"id":"stdthreadhardware_concurrency","depth":2,"text":"std::thread::hardware_concurrency()"},{"id":"referências","depth":2,"text":"Referências"}]}},"_type":"markdown","_id":"content:til:cpp-thread.md","_source":"content","_file":"til/cpp-thread.md","_extension":"md"}