[{"_path":"/til/cpp-magic-enum","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Magic Enum C++","description":"Biblioteca C++17 header-only que provê reflexão estática de enums, trabalha com qualquer tipo de enum sem usar macros.","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Biblioteca C++17 header-only que provê reflexão estática de enums, trabalha com qualquer tipo de enum sem usar macros."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_cast"}]},{"type":"text","value":" obtains enum value from string or integer."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_value"}]},{"type":"text","value":" returns enum value at specified index."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_values"}]},{"type":"text","value":" obtains enum value sequence."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_count"}]},{"type":"text","value":" returns number of enum values."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_integer"}]},{"type":"text","value":" obtains integer value from enum value."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_name"}]},{"type":"text","value":" returns string name from enum value."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_names"}]},{"type":"text","value":" obtains string enum name sequence."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_entries"}]},{"type":"text","value":" obtains pair (value enum, string enum name) sequence."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_index"}]},{"type":"text","value":" obtains index in enum value sequence from enum value."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_contains"}]},{"type":"text","value":" checks whether enum contains enumerator with such value."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_type_name"}]},{"type":"text","value":" returns string name of enum type."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"is_unscoped_enum"}]},{"type":"text","value":" checks whether type is an Unscoped enumeration."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"is_scoped_enum"}]},{"type":"text","value":" checks whether type is an Scoped enumeration."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"underlying_type"}]},{"type":"text","value":" improved UB-free \"SFINAE-friendly\" std::underlying_type."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ostream_operators"}]},{"type":"text","value":" ostream operators for enums."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"bitwise_operators"}]},{"type":"text","value":" bitwise operators for enums."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inserir exemplos"}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/Neargye/magic_enum","rel":["nofollow"]},"children":[{"type":"text","value":"Magic Enum C++"}]}]}]}]},"date":"2020-06-27T00:00:00.000Z","draft":true,"tags":["C++","cpp"],"Thumbnail":"img/headers/debian.jpg","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Biblioteca C++17 header-only que provê reflexão estática de enums, trabalha com qualquer tipo de enum sem usar macros."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_cast"}]},{"type":"text","value":" obtains enum value from string or integer."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_value"}]},{"type":"text","value":" returns enum value at specified index."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_values"}]},{"type":"text","value":" obtains enum value sequence."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_count"}]},{"type":"text","value":" returns number of enum values."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_integer"}]},{"type":"text","value":" obtains integer value from enum value."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_name"}]},{"type":"text","value":" returns string name from enum value."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_names"}]},{"type":"text","value":" obtains string enum name sequence."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_entries"}]},{"type":"text","value":" obtains pair (value enum, string enum name) sequence."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_index"}]},{"type":"text","value":" obtains index in enum value sequence from enum value."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_contains"}]},{"type":"text","value":" checks whether enum contains enumerator with such value."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"enum_type_name"}]},{"type":"text","value":" returns string name of enum type."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"is_unscoped_enum"}]},{"type":"text","value":" checks whether type is an Unscoped enumeration."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"is_scoped_enum"}]},{"type":"text","value":" checks whether type is an Scoped enumeration."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"underlying_type"}]},{"type":"text","value":" improved UB-free \"SFINAE-friendly\" std::underlying_type."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ostream_operators"}]},{"type":"text","value":" ostream operators for enums."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"bitwise_operators"}]},{"type":"text","value":" bitwise operators for enums."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inserir exemplos"}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/Neargye/magic_enum","rel":["nofollow"]},"children":[{"type":"text","value":"Magic Enum C++"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"referências","depth":2,"text":"Referências"}]}},"_type":"markdown","_id":"content:til:cpp-magic-enum.md","_source":"content","_file":"til/cpp-magic-enum.md","_extension":"md"},{"_path":"/til/app-djinni","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Desenvolvendo em C++ para mobile com Djinni","description":"Como criar aplicativos para android e IOS usando C++ com Djinni.","excerpt":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.dropbox.com/s/k1b214bsqgpx4e6/Djinni%20Talk%20-%20CppCon%202015.pdf?dl=0","rel":["nofollow"]},"children":[{"type":"text","value":"Bindings Languages Cross-Platform"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.udemy.com/course/desenvolvendo-aplicativos-mobile-com-cpp-para-android-e-ios/","rel":["nofollow"]},"children":[{"type":"text","value":"Desenvolvendo Aplicativos Mobile com C++ para Android e iOS"}]}]}]}]},"date":"2020-06-23T00:00:00.000Z","draft":true,"tags":["C++","cpp","Djinni"],"Thumbnail":"img/headers/cpp.jpg","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.dropbox.com/s/k1b214bsqgpx4e6/Djinni%20Talk%20-%20CppCon%202015.pdf?dl=0","rel":["nofollow"]},"children":[{"type":"text","value":"Bindings Languages Cross-Platform"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.udemy.com/course/desenvolvendo-aplicativos-mobile-com-cpp-para-android-e-ios/","rel":["nofollow"]},"children":[{"type":"text","value":"Desenvolvendo Aplicativos Mobile com C++ para Android e iOS"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"referências","depth":2,"text":"Referências"}]}},"_type":"markdown","_id":"content:til:app-djinni.md","_source":"content","_file":"til/app-djinni.md","_extension":"md"},{"_path":"/til/cpp-thread","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Thread em C++","description":"Escrevendo funções e classes para execução em paralelo.","excerpt":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"thread-com-função-sem-argumentos"},"children":[{"type":"text","value":"Thread com função sem argumentos"}]},{"type":"element","tag":"code","props":{"code":"void foo() {\n  cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n}\n\nvoid run () {\n  thread t1( foo );\n  // Algum processamento...\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void foo() {\n  cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n}\n\nvoid run () {\n  thread t1( foo );\n  // Algum processamento...\n  t1.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-função-passando-parâmetros-por-valor"},"children":[{"type":"text","value":"Thread com função passando parâmetros por valor"}]},{"type":"element","tag":"code","props":{"code":"void fooByRef( int & a ) {\n  while( true ) {\n    cout << \"O valor é \" << a << endl;\n    this_thread::sleep_for( chrono::milliseconds( 1000 ) );\n  }\n}\n\nvoid run () {\n  int p = 9;\n  thread t2( fooByRef, std::ref( p ) ); // usar o wrapper ref para não passar por valor\n  // Algum processamento...\n  this_thread::sleep_for( chrono::milliseconds( 5000 ) );\n  p = 30;\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void fooByRef( int & a ) {\n  while( true ) {\n    cout << \"O valor é \" << a << endl;\n    this_thread::sleep_for( chrono::milliseconds( 1000 ) );\n  }\n}\n\nvoid run () {\n  int p = 9;\n  thread t2( fooByRef, std::ref( p ) ); // usar o wrapper ref para não passar por valor\n  // Algum processamento...\n  this_thread::sleep_for( chrono::milliseconds( 5000 ) );\n  p = 30;\n  t1.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-função-passando-parâmetros-por-referência"},"children":[{"type":"text","value":"Thread com função passando parâmetros por referência"}]},{"type":"element","tag":"code","props":{"code":"void foo( int a, int b ) {\n}\n\nvoid run () {\n  int p = 9;\n  int q = 8;\n  thread t1( foo, p, q );\n  // Algum processamento...\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void foo( int a, int b ) {\n}\n\nvoid run () {\n  int p = 9;\n  int q = 8;\n  thread t1( foo, p, q );\n  // Algum processamento...\n  t1.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-classe-callable"},"children":[{"type":"text","value":"Thread com classe callable"}]},{"type":"element","tag":"code","props":{"code":"class CallableClass {\n  public:\n    void operator()() {\n      cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n    }\n};\n\nvoid run() {\n  CallableClass obj;\n  thread t2( obj );\n  // Algum processamento...\n  t2.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class CallableClass {\n  public:\n    void operator()() {\n      cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n    }\n};\n\nvoid run() {\n  CallableClass obj;\n  thread t2( obj );\n  // Algum processamento...\n  t2.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-lambda"},"children":[{"type":"text","value":"Thread com lambda"}]},{"type":"element","tag":"code","props":{"code":"// Sintaxe\n// [capture-list]( params ) /*mutable*/ /*constexpr*/ /*exception attribute*/ -> ret { body }\n// [capture-list]( params ) -> ret { body }\n// [capture-list]( params ) { body }\n// [capture-list]{ body }\n\nvoid run() {\n  thread t3( []{\n    cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n  } );\n  // Algum processamento...\n  t3.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Sintaxe\n// [capture-list]( params ) /*mutable*/ /*constexpr*/ /*exception attribute*/ -> ret { body }\n// [capture-list]( params ) -> ret { body }\n// [capture-list]( params ) { body }\n// [capture-list]{ body }\n\nvoid run() {\n  thread t3( []{\n    cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n  } );\n  // Algum processamento...\n  t3.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"join-detach-e-terminate"},"children":[{"type":"text","value":"Join, detach e terminate"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Uma thread representa um objeto de execução em nível de hardware e está num estado chamado "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"joinable"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A opções no estado "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"joinable"}]},{"type":"text","value":" são:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" - introduz um ponto de sincronismo e bloqueia a execução"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"detach"}]},{"type":"text","value":" - faz a execução continuar em modo independente"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Após esta escolha a thread se torna "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"non joinable"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Se esquecer de realizar o join ou detach a função "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::terminate"}]},{"type":"text","value":" será chamada pelo destrutor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Um programa com "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::terminate"}]},{"type":"text","value":" é considerado não seguro."}]}]},{"type":"element","tag":"h2","props":{"id":"tratamento-de-exceção"},"children":[{"type":"text","value":"Tratamento de exceção"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Para evitar problemas caso uma exceção for lançada antes do "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" use\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"RAII - Resource acquisition is initialization"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RAII:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Construtor adquire os recursos"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Destrutor libera os recursos"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemplo de código com problema:"}]},{"type":"element","tag":"code","props":{"code":"void run() {\n  thread t4( foo );\n  throw runtime_error( \"Algum erro antes do join/detach\" );\n  t4.join(); // esta linha nunca vai ser executada\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void run() {\n  thread t4( foo );\n  throw runtime_error( \"Algum erro antes do join/detach\" );\n  t4.join(); // esta linha nunca vai ser executada\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A classe "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ThreadGuard"}]},{"type":"text","value":" fornece um auxiliar para garantir que o "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" será\nsempre executado quando o objeto sair do contexto."}]},{"type":"element","tag":"code","props":{"code":"class ThreadGuard {\n  thread & mThread;\n\n  public:\n    // garantir que não haverá conversões implícitas\n    explicit ThreadGuard( thread & t ) : mThread( t ) {  }\n\n    // realiza o join pelo destrutor\n    ~ThreadGuard() { if( mThread.joinable() ) { mThread.join(); } }\n\n    // não permite o uso dos contrutores de cópia e atribuição\n    ThreadGuard( const ThreadGuard & ) = delete;\n    ThreadGuard & operator= ( const ThreadGuard & ) = delete;\n};\n\nvoid run() {\n  thread t4( foo );\n  ThreadGuard tg( t4 ); // quando sair do escopo o join será chamado\n  throw runtime_error( \"Este erro não afeta a thread acima\" );\n}\n","filename":"6,9","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class ThreadGuard {\n  thread & mThread;\n\n  public:\n    // garantir que não haverá conversões implícitas\n    explicit ThreadGuard( thread & t ) : mThread( t ) {  }\n\n    // realiza o join pelo destrutor\n    ~ThreadGuard() { if( mThread.joinable() ) { mThread.join(); } }\n\n    // não permite o uso dos contrutores de cópia e atribuição\n    ThreadGuard( const ThreadGuard & ) = delete;\n    ThreadGuard & operator= ( const ThreadGuard & ) = delete;\n};\n\nvoid run() {\n  thread t4( foo );\n  ThreadGuard tg( t4 ); // quando sair do escopo o join será chamado\n  throw runtime_error( \"Este erro não afeta a thread acima\" );\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"transferindo-a-posse-das-threads"},"children":[{"type":"text","value":"Transferindo a posse das threads"}]},{"type":"element","tag":"code","props":{"code":"void foo() { }\nvoid bar() { }\n\nvoid run() {\n  thread t1( foo );\n  // thread t2 = t1; // Se fizer isso vai gerar erro de compilação\n\n  // usar move para transferir a posse da thread\n  thread t2 = std::move( t1 ); // t1 não é mais dono da thread\n  t1 = thread( bar ); // t1 tem nova thread\n\n  t1.join();\n  t2.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void foo() { }\nvoid bar() { }\n\nvoid run() {\n  thread t1( foo );\n  // thread t2 = t1; // Se fizer isso vai gerar erro de compilação\n\n  // usar move para transferir a posse da thread\n  thread t2 = std::move( t1 ); // t1 não é mais dono da thread\n  t1 = thread( bar ); // t1 tem nova thread\n\n  t1.join();\n  t2.join();\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"threadget_id"},"children":[{"type":"text","value":"thread::get_id()"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna um id único para cada thread ativa em execução"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna 0 para todas as threads não ativas"}]}]},{"type":"element","tag":"code","props":{"code":"void run() {\n  thread t1( foo );\n  thread t2( foo );\n  thread t3;\n\n  cout << t1.get_id() << endl; // 1234\n  cout << t2.get_id() << endl; // 5678\n  cout << t3.get_id() << endl; // 0\n\n  t1.join();\n  t2.join();\n\n  cout << t1.get_id() << endl; // 0\n  cout << t2.get_id() << endl; // 0\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void run() {\n  thread t1( foo );\n  thread t2( foo );\n  thread t3;\n\n  cout << t1.get_id() << endl; // 1234\n  cout << t2.get_id() << endl; // 5678\n  cout << t3.get_id() << endl; // 0\n\n  t1.join();\n  t2.join();\n\n  cout << t1.get_id() << endl; // 0\n  cout << t2.get_id() << endl; // 0\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"sleep_for"},"children":[{"type":"text","value":"sleep_for"}]},{"type":"element","tag":"h2","props":{"id":"stdthis_threadyield"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::this_thread::yield()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna a fatia de tempo"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"reinsere a thread na fila de execução"}]}]},{"type":"element","tag":"h2","props":{"id":"stdthreadhardware_concurrency"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread::hardware_concurrency()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna o número de thread concorrentes suportado pela implementação do sistema"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"considere este valor apenas como uma dica"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"é usualmente o número de cores lógicos"}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.udemy.com/course/modern-cpp-concurrency-in-depth/","rel":["nofollow"]},"children":[{"type":"text","value":"Modern C++ Concurrency in Depth"}]}]}]}]},"date":"2020-06-23T00:00:00.000Z","draft":false,"tags":["C++","cpp","thread"],"Thumbnail":"img/headers/cpp.png","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"thread-com-função-sem-argumentos"},"children":[{"type":"text","value":"Thread com função sem argumentos"}]},{"type":"element","tag":"code","props":{"code":"void foo() {\n  cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n}\n\nvoid run () {\n  thread t1( foo );\n  // Algum processamento...\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void foo() {\n  cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n}\n\nvoid run () {\n  thread t1( foo );\n  // Algum processamento...\n  t1.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-função-passando-parâmetros-por-valor"},"children":[{"type":"text","value":"Thread com função passando parâmetros por valor"}]},{"type":"element","tag":"code","props":{"code":"void fooByRef( int & a ) {\n  while( true ) {\n    cout << \"O valor é \" << a << endl;\n    this_thread::sleep_for( chrono::milliseconds( 1000 ) );\n  }\n}\n\nvoid run () {\n  int p = 9;\n  thread t2( fooByRef, std::ref( p ) ); // usar o wrapper ref para não passar por valor\n  // Algum processamento...\n  this_thread::sleep_for( chrono::milliseconds( 5000 ) );\n  p = 30;\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void fooByRef( int & a ) {\n  while( true ) {\n    cout << \"O valor é \" << a << endl;\n    this_thread::sleep_for( chrono::milliseconds( 1000 ) );\n  }\n}\n\nvoid run () {\n  int p = 9;\n  thread t2( fooByRef, std::ref( p ) ); // usar o wrapper ref para não passar por valor\n  // Algum processamento...\n  this_thread::sleep_for( chrono::milliseconds( 5000 ) );\n  p = 30;\n  t1.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-função-passando-parâmetros-por-referência"},"children":[{"type":"text","value":"Thread com função passando parâmetros por referência"}]},{"type":"element","tag":"code","props":{"code":"void foo( int a, int b ) {\n}\n\nvoid run () {\n  int p = 9;\n  int q = 8;\n  thread t1( foo, p, q );\n  // Algum processamento...\n  t1.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void foo( int a, int b ) {\n}\n\nvoid run () {\n  int p = 9;\n  int q = 8;\n  thread t1( foo, p, q );\n  // Algum processamento...\n  t1.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-classe-callable"},"children":[{"type":"text","value":"Thread com classe callable"}]},{"type":"element","tag":"code","props":{"code":"class CallableClass {\n  public:\n    void operator()() {\n      cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n    }\n};\n\nvoid run() {\n  CallableClass obj;\n  thread t2( obj );\n  // Algum processamento...\n  t2.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"class CallableClass {\n  public:\n    void operator()() {\n      cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n    }\n};\n\nvoid run() {\n  CallableClass obj;\n  thread t2( obj );\n  // Algum processamento...\n  t2.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"thread-com-lambda"},"children":[{"type":"text","value":"Thread com lambda"}]},{"type":"element","tag":"code","props":{"code":"// Sintaxe\n// [capture-list]( params ) /*mutable*/ /*constexpr*/ /*exception attribute*/ -> ret { body }\n// [capture-list]( params ) -> ret { body }\n// [capture-list]( params ) { body }\n// [capture-list]{ body }\n\nvoid run() {\n  thread t3( []{\n    cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n  } );\n  // Algum processamento...\n  t3.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"// Sintaxe\n// [capture-list]( params ) /*mutable*/ /*constexpr*/ /*exception attribute*/ -> ret { body }\n// [capture-list]( params ) -> ret { body }\n// [capture-list]( params ) { body }\n// [capture-list]{ body }\n\nvoid run() {\n  thread t3( []{\n    cout << \"Corpo da função: \" << this_thread::get_id() << endl;\n  } );\n  // Algum processamento...\n  t3.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"join-detach-e-terminate"},"children":[{"type":"text","value":"Join, detach e terminate"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Uma thread representa um objeto de execução em nível de hardware e está num estado chamado "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"joinable"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A opções no estado "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"joinable"}]},{"type":"text","value":" são:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" - introduz um ponto de sincronismo e bloqueia a execução"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"detach"}]},{"type":"text","value":" - faz a execução continuar em modo independente"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Após esta escolha a thread se torna "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"non joinable"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Se esquecer de realizar o join ou detach a função "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::terminate"}]},{"type":"text","value":" será chamada pelo destrutor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Um programa com "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::terminate"}]},{"type":"text","value":" é considerado não seguro."}]}]},{"type":"element","tag":"h2","props":{"id":"tratamento-de-exceção"},"children":[{"type":"text","value":"Tratamento de exceção"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Para evitar problemas caso uma exceção for lançada antes do "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" use\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"RAII - Resource acquisition is initialization"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RAII:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Construtor adquire os recursos"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Destrutor libera os recursos"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemplo de código com problema:"}]},{"type":"element","tag":"code","props":{"code":"void run() {\n  thread t4( foo );\n  throw runtime_error( \"Algum erro antes do join/detach\" );\n  t4.join(); // esta linha nunca vai ser executada\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void run() {\n  thread t4( foo );\n  throw runtime_error( \"Algum erro antes do join/detach\" );\n  t4.join(); // esta linha nunca vai ser executada\n}"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A classe "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ThreadGuard"}]},{"type":"text","value":" fornece um auxiliar para garantir que o "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"join"}]},{"type":"text","value":" será\nsempre executado quando o objeto sair do contexto."}]},{"type":"element","tag":"code","props":{"code":"class ThreadGuard {\n  thread & mThread;\n\n  public:\n    // garantir que não haverá conversões implícitas\n    explicit ThreadGuard( thread & t ) : mThread( t ) {  }\n\n    // realiza o join pelo destrutor\n    ~ThreadGuard() { if( mThread.joinable() ) { mThread.join(); } }\n\n    // não permite o uso dos contrutores de cópia e atribuição\n    ThreadGuard( const ThreadGuard & ) = delete;\n    ThreadGuard & operator= ( const ThreadGuard & ) = delete;\n};\n\nvoid run() {\n  thread t4( foo );\n  ThreadGuard tg( t4 ); // quando sair do escopo o join será chamado\n  throw runtime_error( \"Este erro não afeta a thread acima\" );\n}\n","filename":"6,9","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"class ThreadGuard {\n  thread & mThread;\n\n  public:\n    // garantir que não haverá conversões implícitas\n    explicit ThreadGuard( thread & t ) : mThread( t ) {  }\n\n    // realiza o join pelo destrutor\n    ~ThreadGuard() { if( mThread.joinable() ) { mThread.join(); } }\n\n    // não permite o uso dos contrutores de cópia e atribuição\n    ThreadGuard( const ThreadGuard & ) = delete;\n    ThreadGuard & operator= ( const ThreadGuard & ) = delete;\n};\n\nvoid run() {\n  thread t4( foo );\n  ThreadGuard tg( t4 ); // quando sair do escopo o join será chamado\n  throw runtime_error( \"Este erro não afeta a thread acima\" );\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"transferindo-a-posse-das-threads"},"children":[{"type":"text","value":"Transferindo a posse das threads"}]},{"type":"element","tag":"code","props":{"code":"void foo() { }\nvoid bar() { }\n\nvoid run() {\n  thread t1( foo );\n  // thread t2 = t1; // Se fizer isso vai gerar erro de compilação\n\n  // usar move para transferir a posse da thread\n  thread t2 = std::move( t1 ); // t1 não é mais dono da thread\n  t1 = thread( bar ); // t1 tem nova thread\n\n  t1.join();\n  t2.join();\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void foo() { }\nvoid bar() { }\n\nvoid run() {\n  thread t1( foo );\n  // thread t2 = t1; // Se fizer isso vai gerar erro de compilação\n\n  // usar move para transferir a posse da thread\n  thread t2 = std::move( t1 ); // t1 não é mais dono da thread\n  t1 = thread( bar ); // t1 tem nova thread\n\n  t1.join();\n  t2.join();\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"threadget_id"},"children":[{"type":"text","value":"thread::get_id()"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna um id único para cada thread ativa em execução"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna 0 para todas as threads não ativas"}]}]},{"type":"element","tag":"code","props":{"code":"void run() {\n  thread t1( foo );\n  thread t2( foo );\n  thread t3;\n\n  cout << t1.get_id() << endl; // 1234\n  cout << t2.get_id() << endl; // 5678\n  cout << t3.get_id() << endl; // 0\n\n  t1.join();\n  t2.join();\n\n  cout << t1.get_id() << endl; // 0\n  cout << t2.get_id() << endl; // 0\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"void run() {\n  thread t1( foo );\n  thread t2( foo );\n  thread t3;\n\n  cout << t1.get_id() << endl; // 1234\n  cout << t2.get_id() << endl; // 5678\n  cout << t3.get_id() << endl; // 0\n\n  t1.join();\n  t2.join();\n\n  cout << t1.get_id() << endl; // 0\n  cout << t2.get_id() << endl; // 0\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"sleep_for"},"children":[{"type":"text","value":"sleep_for"}]},{"type":"element","tag":"h2","props":{"id":"stdthis_threadyield"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::this_thread::yield()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna a fatia de tempo"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"reinsere a thread na fila de execução"}]}]},{"type":"element","tag":"h2","props":{"id":"stdthreadhardware_concurrency"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread::hardware_concurrency()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"retorna o número de thread concorrentes suportado pela implementação do sistema"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"considere este valor apenas como uma dica"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"é usualmente o número de cores lógicos"}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.udemy.com/course/modern-cpp-concurrency-in-depth/","rel":["nofollow"]},"children":[{"type":"text","value":"Modern C++ Concurrency in Depth"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"thread-com-função-sem-argumentos","depth":2,"text":"Thread com função sem argumentos"},{"id":"thread-com-função-passando-parâmetros-por-valor","depth":2,"text":"Thread com função passando parâmetros por valor"},{"id":"thread-com-função-passando-parâmetros-por-referência","depth":2,"text":"Thread com função passando parâmetros por referência"},{"id":"thread-com-classe-callable","depth":2,"text":"Thread com classe callable"},{"id":"thread-com-lambda","depth":2,"text":"Thread com lambda"},{"id":"join-detach-e-terminate","depth":2,"text":"Join, detach e terminate"},{"id":"tratamento-de-exceção","depth":2,"text":"Tratamento de exceção"},{"id":"transferindo-a-posse-das-threads","depth":2,"text":"Transferindo a posse das threads"},{"id":"threadget_id","depth":2,"text":"thread::get_id()"},{"id":"sleep_for","depth":2,"text":"sleep_for"},{"id":"stdthis_threadyield","depth":2,"text":"std::this_thread::yield()"},{"id":"stdthreadhardware_concurrency","depth":2,"text":"std::thread::hardware_concurrency()"},{"id":"referências","depth":2,"text":"Referências"}]}},"_type":"markdown","_id":"content:til:cpp-thread.md","_source":"content","_file":"til/cpp-thread.md","_extension":"md"},{"_path":"/til/cpp-constexpr","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"C++ - otimização com constexpr","description":"Otimização com constexpr.","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A linguagem C++ possui o conceito de expressões constantes (p.e. "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"1+2"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"3*4"}]},{"type":"text","value":")\nque SEMPRE produzem o mesmo resultado sem nenhum efeito colateral. Se\no compilador puder diretamente otimizar e embutir esta expressões no programa\nem tempo de compilação teremos um ganho de performance."}]},{"type":"element","tag":"code","props":{"code":"#include <iostream>\n#define LEN 10\nint len_foo() {\n    int i = 2;\n    return i;\n}\nconstexpr int len_foo_constexpr() {\n    return 5;\n}\n\n// Pode ser usado em recursão\nconstexpr int fibonacci(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);\n}\n\nint main() {\n    char arr_1[10];                      // legal\n    char arr_2[LEN];                     // legal\n    int len = 10;\n    // char arr_3[len];                  // ilegal\n    const int len_2 = len + 1;\n    constexpr int len_2_constexpr = 1 + 2 + 3;\n    // char arr_4[len_2];                // ilegal, mas aceito por vários compiladores\n    // len_2 apesar de constante não é formado somente por constantes\n    char arr_4[len_2_constexpr];         // legal\n    // char arr_5[len_foo()+5];          // ilegal\n    char arr_6[len_foo_constexpr() + 1]; // legal\n    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n    std::cout << fibonacci(10) << std::endl;\n    return 0;\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#include <iostream>\n#define LEN 10\nint len_foo() {\n    int i = 2;\n    return i;\n}\nconstexpr int len_foo_constexpr() {\n    return 5;\n}\n\n// Pode ser usado em recursão\nconstexpr int fibonacci(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);\n}\n\nint main() {\n    char arr_1[10];                      // legal\n    char arr_2[LEN];                     // legal\n    int len = 10;\n    // char arr_3[len];                  // ilegal\n    const int len_2 = len + 1;\n    constexpr int len_2_constexpr = 1 + 2 + 3;\n    // char arr_4[len_2];                // ilegal, mas aceito por vários compiladores\n    // len_2 apesar de constante não é formado somente por constantes\n    char arr_4[len_2_constexpr];         // legal\n    // char arr_5[len_foo()+5];          // ilegal\n    char arr_6[len_foo_constexpr() + 1]; // legal\n    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n    std::cout << fibonacci(10) << std::endl;\n    return 0;\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://itbook.xuxinkai.cn/read/modern-cpp-tutorial-en/02-usability.md","rel":["nofollow"]},"children":[{"type":"text","value":"Chapter 02: Language Usability Enhancements"}]}]}]}]},"date":"2020-05-04T00:00:00.000Z","draft":true,"tags":["C++","cpp","constexpr"],"Thumbnail":"img/headers/cpp.png","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A linguagem C++ possui o conceito de expressões constantes (p.e. "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"1+2"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"3*4"}]},{"type":"text","value":")\nque SEMPRE produzem o mesmo resultado sem nenhum efeito colateral. Se\no compilador puder diretamente otimizar e embutir esta expressões no programa\nem tempo de compilação teremos um ganho de performance."}]},{"type":"element","tag":"code","props":{"code":"#include <iostream>\n#define LEN 10\nint len_foo() {\n    int i = 2;\n    return i;\n}\nconstexpr int len_foo_constexpr() {\n    return 5;\n}\n\n// Pode ser usado em recursão\nconstexpr int fibonacci(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);\n}\n\nint main() {\n    char arr_1[10];                      // legal\n    char arr_2[LEN];                     // legal\n    int len = 10;\n    // char arr_3[len];                  // ilegal\n    const int len_2 = len + 1;\n    constexpr int len_2_constexpr = 1 + 2 + 3;\n    // char arr_4[len_2];                // ilegal, mas aceito por vários compiladores\n    // len_2 apesar de constante não é formado somente por constantes\n    char arr_4[len_2_constexpr];         // legal\n    // char arr_5[len_foo()+5];          // ilegal\n    char arr_6[len_foo_constexpr() + 1]; // legal\n    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n    std::cout << fibonacci(10) << std::endl;\n    return 0;\n}\n","language":"c++"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"#include <iostream>\n#define LEN 10\nint len_foo() {\n    int i = 2;\n    return i;\n}\nconstexpr int len_foo_constexpr() {\n    return 5;\n}\n\n// Pode ser usado em recursão\nconstexpr int fibonacci(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);\n}\n\nint main() {\n    char arr_1[10];                      // legal\n    char arr_2[LEN];                     // legal\n    int len = 10;\n    // char arr_3[len];                  // ilegal\n    const int len_2 = len + 1;\n    constexpr int len_2_constexpr = 1 + 2 + 3;\n    // char arr_4[len_2];                // ilegal, mas aceito por vários compiladores\n    // len_2 apesar de constante não é formado somente por constantes\n    char arr_4[len_2_constexpr];         // legal\n    // char arr_5[len_foo()+5];          // ilegal\n    char arr_6[len_foo_constexpr() + 1]; // legal\n    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n    std::cout << fibonacci(10) << std::endl;\n    return 0;\n}"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://itbook.xuxinkai.cn/read/modern-cpp-tutorial-en/02-usability.md","rel":["nofollow"]},"children":[{"type":"text","value":"Chapter 02: Language Usability Enhancements"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"referências","depth":2,"text":"Referências"}]}},"_type":"markdown","_id":"content:til:cpp-constexpr.md","_source":"content","_file":"til/cpp-constexpr.md","_extension":"md"},{"_path":"/til/cpp-clant-tidy","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Otimizando código com clang-tidy","description":"Como atualizar seu código C++ utilizando a ferramenta clang-tity.","excerpt":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"instalação"},"children":[{"type":"text","value":"Instalação"}]},{"type":"element","tag":"code","props":{"code":"apt-get install clang-tidy\n","language":"bash"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"apt-get install clang-tidy\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"verificadores-disponíveis"},"children":[{"type":"text","value":"Verificadores disponíveis"}]},{"type":"element","tag":"code","props":{"code":"clang-tidy --list-checks -checks='*' | grep \"modernize\"\n    modernize-avoid-bind\n    modernize-deprecated-headers\n    modernize-loop-convert\n    modernize-make-shared\n    modernize-make-unique\n    modernize-pass-by-value\n    modernize-raw-string-literal\n    modernize-redundant-void-arg\n    modernize-replace-auto-ptr\n    modernize-replace-random-shuffle\n    modernize-return-braced-init-list\n    modernize-shrink-to-fit\n    modernize-unary-static-assert\n    modernize-use-auto\n    modernize-use-bool-literals\n    modernize-use-default-member-init\n    modernize-use-emplace\n    modernize-use-equals-default\n    modernize-use-equals-delete\n    modernize-use-noexcept\n    modernize-use-nullptr\n    modernize-use-override\n    modernize-use-transparent-functors\n    modernize-use-uncaught-exceptions\n    modernize-use-using\n","language":"bash"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"clang-tidy --list-checks -checks='*' | grep \"modernize\"\n    modernize-avoid-bind\n    modernize-deprecated-headers\n    modernize-loop-convert\n    modernize-make-shared\n    modernize-make-unique\n    modernize-pass-by-value\n    modernize-raw-string-literal\n    modernize-redundant-void-arg\n    modernize-replace-auto-ptr\n    modernize-replace-random-shuffle\n    modernize-return-braced-init-list\n    modernize-shrink-to-fit\n    modernize-unary-static-assert\n    modernize-use-auto\n    modernize-use-bool-literals\n    modernize-use-default-member-init\n    modernize-use-emplace\n    modernize-use-equals-default\n    modernize-use-equals-delete\n    modernize-use-noexcept\n    modernize-use-nullptr\n    modernize-use-override\n    modernize-use-transparent-functors\n    modernize-use-uncaught-exceptions\n    modernize-use-using\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"uso"},"children":[{"type":"text","value":"Uso"}]},{"type":"element","tag":"code","props":{"code":"clang-tidy -checks='modernize-use-override' -fix test.cpp -- -std=c++11\n","language":"bash"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"clang-tidy -checks='modernize-use-override' -fix test.cpp -- -std=c++11\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://clang.llvm.org/extra/clang-tidy/","rel":["nofollow"]},"children":[{"type":"text","value":"Extra Clang Tools 10 documentation - CLANG-TIDY"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/KratosMultiphysics/Kratos/wiki/How-to-use-Clang-Tidy-to-automatically-correct-code","rel":["nofollow"]},"children":[{"type":"text","value":"How to use Clang Tidy to automatically correct code"}]}]}]}]},"date":"2020-01-13T00:00:00.000Z","draft":false,"tags":["C++","cpp","clang-tidy"],"Thumbnail":"img/headers/cpp.png","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"instalação"},"children":[{"type":"text","value":"Instalação"}]},{"type":"element","tag":"code","props":{"code":"apt-get install clang-tidy\n","language":"bash"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"apt-get install clang-tidy"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"verificadores-disponíveis"},"children":[{"type":"text","value":"Verificadores disponíveis"}]},{"type":"element","tag":"code","props":{"code":"clang-tidy --list-checks -checks='*' | grep \"modernize\"\n    modernize-avoid-bind\n    modernize-deprecated-headers\n    modernize-loop-convert\n    modernize-make-shared\n    modernize-make-unique\n    modernize-pass-by-value\n    modernize-raw-string-literal\n    modernize-redundant-void-arg\n    modernize-replace-auto-ptr\n    modernize-replace-random-shuffle\n    modernize-return-braced-init-list\n    modernize-shrink-to-fit\n    modernize-unary-static-assert\n    modernize-use-auto\n    modernize-use-bool-literals\n    modernize-use-default-member-init\n    modernize-use-emplace\n    modernize-use-equals-default\n    modernize-use-equals-delete\n    modernize-use-noexcept\n    modernize-use-nullptr\n    modernize-use-override\n    modernize-use-transparent-functors\n    modernize-use-uncaught-exceptions\n    modernize-use-using\n","language":"bash"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"clang-tidy --list-checks -checks="}]},{"type":"element","tag":"span","props":{"class":"ct-2458e1"},"children":[{"type":"text","value":"'*'"}]},{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-7c0880"},"children":[{"type":"text","value":"|"}]},{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":" grep "}]},{"type":"element","tag":"span","props":{"class":"ct-2458e1"},"children":[{"type":"text","value":"\"modernize\""}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-avoid-bind"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-deprecated-headers"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-loop-convert"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-make-shared"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-make-unique"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-pass-by-value"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-raw-string-literal"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-redundant-void-arg"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-replace-auto-ptr"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-replace-random-shuffle"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-return-braced-init-list"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-shrink-to-fit"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-unary-static-assert"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-auto"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-bool-literals"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-default-member-init"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-emplace"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-equals-default"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-equals-delete"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-noexcept"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-nullptr"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-override"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-transparent-functors"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-uncaught-exceptions"}]}]},{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"    modernize-use-using"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"uso"},"children":[{"type":"text","value":"Uso"}]},{"type":"element","tag":"code","props":{"code":"clang-tidy -checks='modernize-use-override' -fix test.cpp -- -std=c++11\n","language":"bash"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":"clang-tidy -checks="}]},{"type":"element","tag":"span","props":{"class":"ct-2458e1"},"children":[{"type":"text","value":"'modernize-use-override'"}]},{"type":"element","tag":"span","props":{"class":"ct-3749d6"},"children":[{"type":"text","value":" -fix test.cpp -- -std=c++11"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"referências"},"children":[{"type":"text","value":"Referências"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://clang.llvm.org/extra/clang-tidy/","rel":["nofollow"]},"children":[{"type":"text","value":"Extra Clang Tools 10 documentation - CLANG-TIDY"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/KratosMultiphysics/Kratos/wiki/How-to-use-Clang-Tidy-to-automatically-correct-code","rel":["nofollow"]},"children":[{"type":"text","value":"How to use Clang Tidy to automatically correct code"}]}]}]},{"type":"element","tag":"style","children":[{"type":"text","value":".ct-7c0880{color:#F92672}.ct-2458e1{color:#E6DB74}.ct-3749d6{color:#F8F8F2}"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"instalação","depth":2,"text":"Instalação"},{"id":"verificadores-disponíveis","depth":2,"text":"Verificadores disponíveis"},{"id":"uso","depth":2,"text":"Uso"},{"id":"referências","depth":2,"text":"Referências"}]}},"_type":"markdown","_id":"content:til:cpp-clant-tidy.md","_source":"content","_file":"til/cpp-clant-tidy.md","_extension":"md"}]