{"_path":"/til/junit-rules","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"JUnit Rules","description":"JUnit Rules","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.infoq.com/news/2009/07/junit-4.7-rules","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.infoq.com/news/2009/07/junit-4.7-rules"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unit 4.7, which has just reached Release Candidate stage, includes a significant new feature: Rules."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Rules are, in essence, another extension mechanism for JUnit, which can be used to add functionality to JUnit on a per-test basis. Most examples of custom runners in earlier versions of JUnit can be replaced by Rules. As described in an earlier blog post about the feature:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In JUnit 3 you could also manipulate the test running process itself in various ways. One of the prices of the simplicity of JUnit 4 was the loss of this “meta-testing”. It doesn’t affect simple tests, but for more powerful tests it can be constraining. The object framework style of JUnit 3 lent itself to extension by default. The DSL style of JUnit 4 doesn’t. Last night we brought back meta-testing, but much cleaner and simpler than before.\nIn addition to the capability of adding rules, a number of core rules have been added:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TemporaryFolder: Allows test to create files and folders that are guaranteed to be deleted after the test is run. This is a common need for tests that work with the filesystem and want to run in isolation.\nExternalResource: A pattern for resources that need to be set up in advance and are guaranteed to be torn down after the test runs. This will be useful for tests that work with sockets, embedded servers, and the like.\nErrorCollector: Allows the test to continue running after a failure and report all errors at the end of the test. Useful when a test verifies a number of independent conditions (although that may itself be a 'test smell').\nExpectedException: Allows a test to specify expected exception types and messages in the test itself.\nTimeout: Applies the same timeout to all tests in a class.\nIf you'd like to see an example of a rule in action, here's a test using the TemporaryFolder and ExpectedException rules:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public class DigitalAssetManagerTest {"}]},{"type":"element","tag":"code","props":{"code":"@Rule\npublic TemporaryFolder tempFolder = new TemporaryFolder();\n\n@Rule\npublic ExpectedException exception = ExpectedException.none();\n\n@Test\npublic void countsAssets() throws IOException {\n    File icon = tempFolder.newFile(\"icon.webp\");\n    File assets = tempFolder.newFolder(\"assets\");\n    createAssets(assets, 3);\n\n    DigitalAssetManager dam = new DigitalAssetManager(icon, assets);\n    assertEquals(3, dam.getAssetCount());\n}\n\nprivate void createAssets(File assets, int numberOfAssets) throws IOException {\n    for (int index = 0; index < numberOfAssets; index++) {\n        File asset = new File(assets, String.format(\"asset-%d.mpg\", index));\n        Assert.assertTrue(\"Asset couldn't be created.\", asset.createNewFile());\n    }\n}\n\n@Test\npublic void throwsIllegalArgumentExceptionIfIconIsNull() {\n    exception.expect(IllegalArgumentException.class);\n    exception.expectMessage(\"Icon is null, not a file, or doesn't exist.\");\n    new DigitalAssetManager(null, null);\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@Rule\npublic TemporaryFolder tempFolder = new TemporaryFolder();\n\n@Rule\npublic ExpectedException exception = ExpectedException.none();\n\n@Test\npublic void countsAssets() throws IOException {\n    File icon = tempFolder.newFile(\"icon.webp\");\n    File assets = tempFolder.newFolder(\"assets\");\n    createAssets(assets, 3);\n\n    DigitalAssetManager dam = new DigitalAssetManager(icon, assets);\n    assertEquals(3, dam.getAssetCount());\n}\n\nprivate void createAssets(File assets, int numberOfAssets) throws IOException {\n    for (int index = 0; index < numberOfAssets; index++) {\n        File asset = new File(assets, String.format(\"asset-%d.mpg\", index));\n        Assert.assertTrue(\"Asset couldn't be created.\", asset.createNewFile());\n    }\n}\n\n@Test\npublic void throwsIllegalArgumentExceptionIfIconIsNull() {\n    exception.expect(IllegalArgumentException.class);\n    exception.expectMessage(\"Icon is null, not a file, or doesn't exist.\");\n    new DigitalAssetManager(null, null);\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}\nTo make rule development easier, a few base classes for rules have been added:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Verifier: A base class for rules like ErrorCollector that can turn failing tests into passing ones if a verification check is failed.\nTestWatchman: A base class for rules that observe the running of tests without modifying the results.\nRules were called Interceptors when they made their first appearance in earlier builds of JUnit 4.7. In addition to the rules, JUnit 4.7 also includes:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Some changes to the matchers.\nTests that timeout now show the stack trace; this can help to diagnose the cause of the test timing out.\nImprovements to Javadoc and a few bugs fixed.\nMore information on these features is available in the JUnit 4.7 release notes.  Hamcrest 1.2 support was listed in earlier release notes, but has been rolled back for this release."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While you're waiting for the final release, you can download the release candidate from github, browse org.junit.rules gear, fill out the survey, read about the deadpooling of Kent Beck's JUnit Max, and wait for user reactions to JUnit 4.7 on blogs, friendfeed and twitter."}]}]},"date":"2019-11-12T00:00:00.000Z","draft":true,"tags":["junit"],"Thumbnail":"img/headers/junit.webp","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.infoq.com/news/2009/07/junit-4.7-rules","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.infoq.com/news/2009/07/junit-4.7-rules"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unit 4.7, which has just reached Release Candidate stage, includes a significant new feature: Rules."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Rules are, in essence, another extension mechanism for JUnit, which can be used to add functionality to JUnit on a per-test basis. Most examples of custom runners in earlier versions of JUnit can be replaced by Rules. As described in an earlier blog post about the feature:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In JUnit 3 you could also manipulate the test running process itself in various ways. One of the prices of the simplicity of JUnit 4 was the loss of this “meta-testing”. It doesn’t affect simple tests, but for more powerful tests it can be constraining. The object framework style of JUnit 3 lent itself to extension by default. The DSL style of JUnit 4 doesn’t. Last night we brought back meta-testing, but much cleaner and simpler than before.\nIn addition to the capability of adding rules, a number of core rules have been added:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TemporaryFolder: Allows test to create files and folders that are guaranteed to be deleted after the test is run. This is a common need for tests that work with the filesystem and want to run in isolation.\nExternalResource: A pattern for resources that need to be set up in advance and are guaranteed to be torn down after the test runs. This will be useful for tests that work with sockets, embedded servers, and the like.\nErrorCollector: Allows the test to continue running after a failure and report all errors at the end of the test. Useful when a test verifies a number of independent conditions (although that may itself be a 'test smell').\nExpectedException: Allows a test to specify expected exception types and messages in the test itself.\nTimeout: Applies the same timeout to all tests in a class.\nIf you'd like to see an example of a rule in action, here's a test using the TemporaryFolder and ExpectedException rules:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public class DigitalAssetManagerTest {"}]},{"type":"element","tag":"code","props":{"code":"@Rule\npublic TemporaryFolder tempFolder = new TemporaryFolder();\n\n@Rule\npublic ExpectedException exception = ExpectedException.none();\n\n@Test\npublic void countsAssets() throws IOException {\n    File icon = tempFolder.newFile(\"icon.webp\");\n    File assets = tempFolder.newFolder(\"assets\");\n    createAssets(assets, 3);\n\n    DigitalAssetManager dam = new DigitalAssetManager(icon, assets);\n    assertEquals(3, dam.getAssetCount());\n}\n\nprivate void createAssets(File assets, int numberOfAssets) throws IOException {\n    for (int index = 0; index < numberOfAssets; index++) {\n        File asset = new File(assets, String.format(\"asset-%d.mpg\", index));\n        Assert.assertTrue(\"Asset couldn't be created.\", asset.createNewFile());\n    }\n}\n\n@Test\npublic void throwsIllegalArgumentExceptionIfIconIsNull() {\n    exception.expect(IllegalArgumentException.class);\n    exception.expectMessage(\"Icon is null, not a file, or doesn't exist.\");\n    new DigitalAssetManager(null, null);\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"@Rule\npublic TemporaryFolder tempFolder = new TemporaryFolder();\n\n@Rule\npublic ExpectedException exception = ExpectedException.none();\n\n@Test\npublic void countsAssets() throws IOException {\n    File icon = tempFolder.newFile(\"icon.webp\");\n    File assets = tempFolder.newFolder(\"assets\");\n    createAssets(assets, 3);\n\n    DigitalAssetManager dam = new DigitalAssetManager(icon, assets);\n    assertEquals(3, dam.getAssetCount());\n}\n\nprivate void createAssets(File assets, int numberOfAssets) throws IOException {\n    for (int index = 0; index < numberOfAssets; index++) {\n        File asset = new File(assets, String.format(\"asset-%d.mpg\", index));\n        Assert.assertTrue(\"Asset couldn't be created.\", asset.createNewFile());\n    }\n}\n\n@Test\npublic void throwsIllegalArgumentExceptionIfIconIsNull() {\n    exception.expect(IllegalArgumentException.class);\n    exception.expectMessage(\"Icon is null, not a file, or doesn't exist.\");\n    new DigitalAssetManager(null, null);\n}"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}\nTo make rule development easier, a few base classes for rules have been added:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Verifier: A base class for rules like ErrorCollector that can turn failing tests into passing ones if a verification check is failed.\nTestWatchman: A base class for rules that observe the running of tests without modifying the results.\nRules were called Interceptors when they made their first appearance in earlier builds of JUnit 4.7. In addition to the rules, JUnit 4.7 also includes:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Some changes to the matchers.\nTests that timeout now show the stack trace; this can help to diagnose the cause of the test timing out.\nImprovements to Javadoc and a few bugs fixed.\nMore information on these features is available in the JUnit 4.7 release notes.  Hamcrest 1.2 support was listed in earlier release notes, but has been rolled back for this release."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While you're waiting for the final release, you can download the release candidate from github, browse org.junit.rules gear, fill out the survey, read about the deadpooling of Kent Beck's JUnit Max, and wait for user reactions to JUnit 4.7 on blogs, friendfeed and twitter."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:til:junit-rules.md","_source":"content","_file":"til/junit-rules.md","_extension":"md"}